import os

import numpy as np
import pandas as pd
import sciris as sc
import starsim as ss

import tb_acf as acf

do_run = True
run_sensitivity = True
plot_calib = False # Only turn this on when you are making plots with the baseline scenarios
baseline_scens_only = False
betasweep = False
mode = 1  #NOTE: mode 2 runs in serial

# Each scenario will be run n_seeds times for each of intervention and control.
top_k = [1, 1, 1][mode] # Parameter configurations
n_seeds = [1, 1, 1][mode]

label = 'Sensitivity'

# Check if the results directory exists, if not, create it
resdir = os.path.join(os.path.dirname(__file__), 'results', f'Scen_{label}')
os.makedirs(resdir, exist_ok=True)
os.makedirs(os.path.join(resdir), exist_ok=True)

def run_ACF(skey, scen, calib_pars, param_idx, rep_idx, rand_seed=0):
    """
    Run a single multisim containing one control and one intervention simulation
    """
    inhost = scen['InHost']
    sim = acf.make_sim(rand_seed, inhost=inhost)
    sim.pars.analyzers += [acf.prev_by_age(year=2013)] # Add the prevalence by age intervention

    cp = {k[7:]: dict(value=v) for k,v in calib_pars.items() if k[:7] == 'params_'} # Convert to a form that can be passed to apply_calib
    cp.pop('rand_seed', None) # Remove the random seed from the calibration parameters
    sim = acf.apply_scen(sim, scen)

    #print('WARNING, MANUALLY CHANGING CALIBRATION')
    #cp['beta']['value'] *= 1.05

    sim = acf.apply_calib(sim, calib_pars=cp) 
    ms = acf.build_arms(sim) # This is where the control arm is added

    # Add metadata for later
    ms.skey = skey
    ms.param_idx = param_idx
    ms.rep_idx = rep_idx

    ms.run()

    tb_res = []
    acf_res = []
    pba_res = []
    for s in ms.sims:
        df = pd.DataFrame({
            'time_year': s.results.timevec,
            'on_treatment': s.results.tb.n_on_treatment, 
            'prevalence': s.results.tb.prevalence,
            'prevalence_active': s.results.tb.prevalence_active,
            'incidence_kpy': s.results.tb.incidence_kpy,
            'n_infected_5': s.results.ageinfect.ninf_5,
            'n_infected_5_6': s.results.ageinfect.ninf_5_6,
            'n_infected_6_15': s.results.ageinfect.ninf_6_15,
            'n_pop_5': s.results.ageinfect.pop_5,
            'n_pop_5_6': s.results.ageinfect.pop_5_6,
            'n_pop_6_15': s.results.ageinfect.pop_6_15,
            })
        if 'TBsim' in inhost:
            df2 = pd.DataFrame({
                'susceptible': s.results.tb.n_susceptible,
                'latent_slow': s.results.tb.n_latent_slow,
                'latent_fast': s.results.tb.n_latent_fast,
                'active': s.results.tb.n_active,
                'active_presymp': s.results.tb.n_active_presymp,
                'active_smpos': s.results.tb.n_active_smpos,
                'active_smneg': s.results.tb.n_active_smneg,
                'active_exptb': s.results.tb.n_active_exptb,
                'population': s.results.n_alive,
            })
            df = pd.concat([df, df2], axis=1)
        else:
            # Add LSHTM channel outputs, if desired
            pass

        df['scenario'] = skey
        df['arm'] = s.label
        df['rand_seed'] = s.pars.rand_seed
        df['param_idx'] = param_idx
        df['rep_idx'] = rep_idx
        df['include'] = True #np.any(s.results.tb.n_infected[s.timevec >= ss.date('2013-01-01')] > 0)
        tb_res.append(df)

        date_cov_keys = list(s.interventions['ACT3 Active Case Finding'].pars.date_cov.keys())
        act3_dates = [ss.date(t) for t in date_cov_keys]
        inds = np.searchsorted(s.results.timevec, act3_dates, side='left')
        df = pd.DataFrame({
            'time_year': s.results.timevec[inds],
            'n_elig': s.results['ACT3 Active Case Finding'].n_elig[inds],
            'n_tested': s.results['ACT3 Active Case Finding'].n_tested[inds],
            'n_positive': s.results['ACT3 Active Case Finding'].n_positive[inds],
            'prev_active': s.results.tb.prevalence_active[inds],
        })

        if 'TBsim' in inhost:
            df2 = pd.DataFrame({
                # Only for TBsim inhost model:
                'n_positive_presymp': s.results['ACT3 Active Case Finding'].n_positive_presymp[inds],
                'n_positive_smpos': s.results['ACT3 Active Case Finding'].n_positive_smpos[inds],
                'n_positive_smneg': s.results['ACT3 Active Case Finding'].n_positive_smneg[inds],
                'n_positive_exp': s.results['ACT3 Active Case Finding'].n_positive_exp[inds],

                'n_positive_via_LF': s.results['ACT3 Active Case Finding'].n_positive_via_LF[inds],
                'n_positive_via_LS': s.results['ACT3 Active Case Finding'].n_positive_via_LS[inds],
                'n_positive_via_LF_dur': s.results['ACT3 Active Case Finding'].n_positive_via_LF_dur[inds],
                'n_positive_via_LS_dur': s.results['ACT3 Active Case Finding'].n_positive_via_LS_dur[inds],
            })
            df = pd.concat([df, df2], axis=1)
        else:
            # Add LSHTM channel outputs, if desired
            pass

        df['scenario'] = skey
        df['arm'] = s.label
        df['rand_seed'] = s.pars.rand_seed
        df['param_idx'] = param_idx
        df['rep_idx'] = rep_idx
        df['include'] = True #np.any(s.results.tb.n_infected[s.timevec >= ss.date('2013-01-01')] > 0)
        acf_res.append(df)

        az = s.analyzers.get('prev_by_age', None)
        if az is None:
            continue
        df = pd.DataFrame({
            'n': az.n,
            'ever': az.ever,
            'infected': az.infected,
            'active': az.active,
        }, index = pd.Index([f'{b}-{e}' for b,e in zip(az.age_bins[:-1], az.age_bins[1:])], name='age bin'))
        df['year'] = ss.date(az.year)
        df['scenario'] = skey
        df['arm'] = s.label
        df['rand_seed'] = s.pars.rand_seed
        df['param_idx'] = param_idx
        df['rep_idx'] = rep_idx
        pba_res.append(df)

    tb_res = pd.concat(tb_res)
    acf_res = pd.concat(acf_res)
    pba_res = pd.concat(pba_res)

    # Additional calculations - TODO: move elsewhere ##########################################################

    # Process the results to calculate the effect of the intervention - 
    # Compare the gradients between the control and the intervention arms
    eff_cols = ['time_year', 'prev_active', 'scenario', 'rand_seed']

    # add the baseline value in the control arm 
    # extract the prevalence at the first time point from the intervention arm and rename it to Control
    tb_control_bl = acf_res[(acf_res['arm'] == 'Intervention') & (acf_res['time_year'] == acf_res['time_year'].min())]
    tb_control_bl.loc[:, "arm"] = "Control"
    # conacatenate the baseline with acf_res
    acf_res = pd.concat([acf_res, tb_control_bl], ignore_index=True)
    # arrange acf_ref by rand_seed, arm, time_year
    acf_res = acf_res.sort_values(by=["rand_seed", "arm", "time_year"])
    
    # Calculate the change in prevalnce between the first and last time points - control
    tb_control_prev_res = acf_res[(acf_res['arm'] == 'Control')][eff_cols]
    tb_control_prev_res = (
        tb_control_prev_res \
            .groupby(['rand_seed', 'scenario']) \
            # for prevalence
            .apply(lambda group: 
                   group.loc[group['time_year'].idxmax(), 'prev_active'] - group.loc[group['time_year'].idxmin(), 'prev_active'], 
                   include_groups=False) \
            .reset_index(name='prev_gradient_ctrl')
    )
    
    # Calculate the change in prevalnce between the first and last time points - intervention
    tb_intervention_prev_res = acf_res[(acf_res['arm'] == 'Intervention')][eff_cols]
    tb_intervention_prev_res = (
        tb_intervention_prev_res \
            .groupby(['rand_seed', 'scenario']) \
            .apply(lambda group: 
                   group.loc[group['time_year'].idxmax(), 'prev_active'] - group.loc[group['time_year'].idxmin(), 'prev_active'], 
                   include_groups=False) \
            .reset_index(name='prev_gradient_intv')
    )
    
    # Merge the two dataframes to calculate the relative change in prevalence - intervention relative to control
    acf_effect_res = pd.merge(tb_control_prev_res, tb_intervention_prev_res, on=['rand_seed', 'scenario'])
    acf_effect_res['relative_prev'] = (acf_effect_res['prev_gradient_intv'] - acf_effect_res['prev_gradient_ctrl'])*100_000

    return {'MS': ms, 'TB': tb_res, 'ACT3': acf_res, 'PBA': pba_res, 'ACT3 Effect': acf_effect_res}


def run_scenarios(scens, n_seeds=n_seeds):
    results = []
    cfgs = []

    seeds = np.random.randint(0, 1e6, n_seeds)

    # Iterate over scenarios and random seeds
    for skey, scen in scens.items():
        calib_pars = scen['CalibPars'] # Dataframe
        for cpi, cp in calib_pars.iterrows():
            for si, seed in enumerate(seeds):
                if 'params_rand_seed' in cp:
                    seed = cp['params_rand_seed'] + si
                else:
                    seed = seeds[si] # Use a random seed because the multisim will increment from this and we don't want to reuse
                # Append configuration for parallel execution
                cfgs.append({'skey': skey, 'scen': scen, 'calib_pars': cp, 'rand_seed': seed, 'param_idx': cpi, 'rep_idx': si})

    # Run simulations in parallel
    T = sc.tic()

    results += sc.parallelize(run_ACF, iterkwargs=cfgs, die=True, serial=(mode==2))

    print(f'That took: {sc.toc(T, output=True):.1f}s')

    msims = {}
    for r in results:
        ms = r.pop('MS') # Remove so not save as csv (below)
        msims[ms.skey] = msims.get(ms.skey, []) + ms.sims
    
    multisims = []
    for k, sims in msims.items():
        ms = ss.MultiSim(sims)
        ms.label = k
        multisims.append(ms)
    sc.saveobj(os.path.join(resdir, f'multisims.obj'), multisims)

    # separate the results for each component of the simulation (TB and ACT3)
    dfs = {}
    for k in results[0].keys():
        df_list = [r.get(k) 
                   for r in results 
                   if r.get(k) is not None
                   ]
        dfs[k] = pd.concat(df_list)
        dfs[k].to_csv(os.path.join(resdir, f'{k}.csv'))
    return dfs, multisims


if __name__ == '__main__':
    gitdir = os.path.join(resdir, 'gitinfo')
    os.makedirs(gitdir, exist_ok=True)
    acf.save_info(gitdir)

    scens = acf.make_scenarios(top_k=top_k, run_sensitivity=True)

    if do_run:
        df_result, multisims = run_scenarios(scens)
    else:
        try:
            multisims = sc.loadobj(os.path.join(resdir, 'multisims.obj'))
            df_result = {}
            for k in ['TB', 'ACT3', 'PBA']:
                df_result[k] = pd.read_csv(os.path.join(resdir, f'{k}.csv'), index_col=0)
                if 'time_year' in df_result[k]:
                    df_result[k]['time_year'] = pd.to_datetime(df_result[k]['time_year'])
        except FileNotFoundError:
            print('No results found, please set do_run to True')
            raise

    # Plot df result, all scenarios combined
    acf.plot_scenarios(df_result.get('TB'), resdir)
    acf.plot_TODO(df_result, resdir)

    if plot_calib:
        resdir_orig = resdir
        for MS in multisims:
            resdir = os.path.join(resdir_orig, MS.label)
            os.makedirs(resdir, exist_ok=True)

            scens[MS.label]['CalibPars'].to_csv(os.path.join(resdir, 'calib_pars.csv')) # Save out the calib pars

            print(MS.label, '-'*50)
            acf.plot_calib(MS, resdir)

        
            acf.plot_ts(MS, resdir)